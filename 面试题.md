### 闭包、堆栈、深浅克隆

#### 堆栈内存

基本类型会直接往栈中存，引用类型会先开堆，最终是把地址赋值给这个值



Example 1：

数字属性名 == 字符串属性名

```js
<script>	
    let a = {},b='0',c=0
    a[b] = '珠峰'
    a[c] = '培训'
    console.log(a[b])	//培训
</script>
```

![cF5in0.png](https://z3.ax1x.com/2021/03/31/cF5in0.png)

Example 2：

Symbol的作用是创建唯一值的

```js
<script>
	let res = Symbol('1')==Symbol('1')
	console.log(res)		//false

    let a = {},
    b = Symbol('1')
    c = Symbol('1')

    a[b] = '珠峰'
    a[c] = '教育'

    console.log(a[b])	//珠峰

</script>
```

Example 3：

引用类型都会变成字符串来进行存储

```js
<script>
		
    let a = {},
    b = {name:'kerwin'}
    c = {age:11}

    a[b] = '珠峰'			//b为objec，会存储为'[Object,Object]'这个字符串
    a[c] = '教育'			//c为objec，也会存储为'[Object,Object]'这个字符串，所以两个键相同个，后边的会覆盖掉前面的

    console.log(a[b])		//教育

</script>

```

alert弹出的值都会转成字符串

```
alert({name:'Kerwin'})   //[Object, Object]
```

Array也是对象的一种表现形式，所以，定义一个数组，里边保存的也是引用，两个变量指向同一个内存地址时，一个改变，另一个也会改变

```js
let arr1 = [1,2,3,4]
let arr2 =arr1
console.log(arr1)
console.log(arr2)

arr1[1] = 10
console.log(arr1)
console.log(arr2)
```

### 预编译





### 作用域链

视频讲解：https://www.bilibili.com/video/BV1Xz4y1S7Zd?p=538

> [[scope]]说明：在函数创建的时候，生成的一个JS内部的隐式属性，这个隐式属性是JS引擎来读取的，它时函数存储作用域的容器

所谓作用域链是指：在每个函数内部都有一个属性，这个属性是[[Scope]]属性，这个属性是不可以操作的。该属性指向了一个集合，这个集合中保存了当前作用域下面变量对象（所谓变量对象就是指，在每个作用域下面都会有一个对象，该作用域下面定义的所有变量和方法都是该对象添加的属性和方法，全局作用于下面的变量对象就是window对象）的地址，以及上级作用域下面的变量对象的地址，这个集合就是作用域链。

当在使用某个变量时，先从当前作用域下面的变量对象上查找，如果有则返回其值，如果没有，则沿着作用域链向上级作用域中的变量对象身上查找，依次网上查找。当找到window对象依然没有找到该变量，那么就报错。

```js
<script>
	var num = 10
	function outer(){
		var num = 20
		
		function inner(){
			console.log(num)	//打印结果为20
		}
		inner()
	}
	
	outer()
</script>
```

### 闭包

视频讲解：https://www.bilibili.com/video/BV1Xz4y1S7Zd?p=539

**原理**：按道理说，每个函数在执行完毕后会从内存中将该函数弹出，如果函数被从内存中弹出，那么该函数的作用域链由于没有东西对它进行引用，那么这个作用域链就会被销毁，该函数的变量对象也就没有被引用，变量对象也会被销毁，闭包之所以可以在外部函数执行完毕后依然能够使用外部环境中的变量，是因为当外部函数被销毁时，由于闭包中使用了外部函数变量对象中的内容，所以外部函数的变量依然会被保存在内存中。

**作用**：可以将函数中定义的变量拿到函数外部来从操作，即闭包在它所在的函数和全局环境中建立起了桥梁。

**不足**：由于闭包会将上级作用域下面的变量对象保存在内存中，那么如果程序中有大量的闭包，势必会造成内存资源的浪费，建议在不使用闭包的时候，手动将闭包清除。

```js
function outer(){
    let a = 100
    
    return function(){
        console.log(a)
    }
}

let res = outer()

//调用闭包函数
res()		//输出100

res = null //不使用闭包的时候，手动将闭包清除。
```

### 立即执行函数

立即执行函数最大的作用就是独立创建了一个作用域，里面所有的变量都是局部变量，不会有命名冲突的情况，同时也避免了定义大量全局变量污染整个全局环境这样一个问题

```js
//定义一个匿名执行函数，功能是在控制台打印一个hello
(function(){
    console.log("Hello")
})()


//定义一个匿名自执行函数，求两个数的和
(function(a,b){
    console.log(a+b)
}(1,2))

//定义一个匿名自执行函数，功能是求两个数的和，将和作为返回值返回
let sum = (function(a,b){
    return a+b
})(1,2)

console.log(sum)
```

### 原型

什么是原型：每个函数（包括构造函数和普通函数）中都会有一个属性-prototype属性，普通函数的原型对象没啥意义，这里的原型一般都值得是构造函数。这个属性指向了一个对象，这个对象就被称为原型对象，简称原型。原型中存储的是通过构造方法创建出来的所有对象可以共享的内容，可以使用构造方法名称.prototype属性来获取原型对象

我们把私有的属性放在构造方法里，比如name,age,sex，

把公共的属性或方法放在原型中，每一个new出的对象都可以使用这个属性和方法

原型对象的 增 删 改 查

```js
<script>
	function Person(name,age,sex){
		this.name = name;
		this.age = age
		this.sex = sex
	}
	
	//为原型添加内容
	Person.prototype.speak = function(){
		console.log('hello')
	}
	
	Person.prototype.nation = '中国'
	Person.prototype.hairColor = 'black'
	
	//更改原型内容
	Person.prototype.hairColor = 'yellow'
	
	
	//删除原型内容
	delete Person.prototype.hairColor
	
	
	//原型内容的获取
	var res = Person.prototype.nation
	console.log(res)
	Person.prototype.speak()
	
	console.log(Person.prototype)
	
	// 原型内容的获取可以直接通过对象来获取， 增 删 改不可以
	var p = new Person("Kerwin",18,"男")
    console.log(p.nation)		//中国
	p.speak()
	
</script>
```

为什么new出来的对象可以直接获取原型中的内容？

是因为：在每个对象中有一个`__proto__` 属性，这个属性指向了创建该对象的原型对象，当利用对象去查找某个属性的时候，属性的查找顺序是：先从自身的私有属性中查找，如果私有属性中有要查找的属性，则返回其对应的值，如果私有属性中没有要查找的属性，则沿着`__proto__`的指向，到原型对象中去查找，如果有就返回其对应的值。

```js
Person.prototype === p.__proto__		//true
```

我们new一个String对象，可以调用String的很多方法，这个就是用到了这个原理

```js
<script>
	var str =new String("hellow")
	console.log(String.prototype)		//String的原型对象
	console.log(str.__proto__)			//String的原型对象

	console.log(str.split(""))			//split方法是String原型中的公有的方法
</script>
```



### 继承

#### 借用构造方法继承 call/apply

借用构造方法继承，继承的是上级构造方法对私有属性的绑定和初始化操作

格式如下：

```
function 构造方法1(){}

function 构造方法2(){

	构造方法1.call/apply(this,实参1,实参2,实参3...)

	this.属性名 = 属性值

	this.属性名 = 属性值

}
```

实例

```js
<script>
	function Person(name,age,sex){
		this.name = name
		this.age = age
		this.sex = sex
	}
	
	function Student(name,age,sex,subject,school,teacher){
        //通过借用构造方法的形式来继承上级构造方法对name、age、sex属性的绑定和初始化操作
		Person.call(this,name,age,sex)
        //Person.apply(this,[name,age,sex])
		this.subject = subject
		this.school = school
		this.teacher = teacher
	}
	
	var stu = new Student('Kerwin',18,'男',['语文','数学','英语'],'正华中学','卫老师')
	var stu2 = new Student('Jack',20,'女',['Chinese','Math','English'],'THU中学','卫老师')
	
	console.log(stu)
	console.log(stu2)
	
</script>
```

#### 原型链继承

视频讲解：https://www.bilibili.com/video/BV1Xz4y1S7Zd?p=547

通过构造方法继承是没法将上级构造函数原型的方法继承下来的，只能继承私有属性的绑定，继承不了原型

所谓原型链继承，就是让下级构造方法的prototype属性指向上级构造方法创建出来的一个实例（对象）

```
function 构造方法1(){}

function 构造方法2(){
	this.属性名 = 属性值
	this.属性名 = 属性值
}

构造方法2.prototype = new 构造方法1()
```

实例

```js
<script>
	function Person(name,age,sex){
		this.name = name
		this.age = age
		this.sex = sex
	}
	Person.prototype.nation = '中国'
	
	Person.prototype.speak = function(){
		console.log("Hello")
	}
	
	function Student(name,age,sex,subject,school,teacher){
		this.subject = subject
		this.school = school
		this.teacher = teacher
	}
		
	//通过原型链继承，让下级构造方法的prototype属性指向上级构造方法创建出来的一个实例
	Student.prototype = new Person()
	//如果采用原型链继承，就会导致下级构造方法原型中的constructor属性的指向发生改变（constructor属性是原型中的一个属性，这个属性默认指向它的构造方法，如果采用原型链继承，那么constructor属性的指向就不再指向自己的构造方法了，所以我们需要将它重新指回自己的构造方法）
	Student.prototype.constructor = Student
	
	var stu = new Student('Kerwin',18,'男',['语文','数学','英语'],'正华中学','卫老师')
	
	console.log(stu.nation)		//中国
	stu.speak()					//Hello
	
</script>
```

到底什么是原型链？所谓原型链，就是指通过原型链继承，在原型之间建立起来的一条链式结构，我们把这条链式结构称为原型链。当对象在操作属性时，先从自身的私有属性中查找，如果有，则返回对应的属性值，如果没有，则沿着自身的`__proto__`属性到它的原型中查找，如果他的原型中也没有，那么就会沿着原型链继续往上查找，如果找到则返回对象的值，如果找到Object原型也没有发现要找的属性，则返回undefined

#### 组合继承

就是将构造方法继承和原型链继承合在一块，既能继承私有属性的绑定，又能继承原型中的东西，这种写法就是组合继承

```js
<script>
	function Person(name,age,sex){
		this.name = name
		this.age = age
		this.sex = sex
	}
	
	Person.prototype.nation = "中国"
	Person.prototype.speak = function(){
        console.log("Hello")
    }
	
	
	function Student(name,age,sex,subject,teacher){
        
        //借用构造方法继承私有属性的绑定
		Person.call(this,name,age,sex)
		this.subject = subject
		this.teacher = teacher
	}
	
	//继承原型中的东西
	Student.prototype = new Person()
	Student.prototype.constructor = Student
	
	var s = new Student('Kerwin',18,'男',['语文','数学','英语'],'卫老师')
	
	console.log(s)
	console.log(s.name)
	console.log(s.nation)
	s.speak()
</script>
```

### 事件对象

什么是事件对象：事件对象是JS中的一个内置对象，该对象记录了和当前事件相关的信息，另外事件对象也提供了当量的属性和方法帮助我们操作对象

事件对象的获取：

谷歌浏览器：JS底层会把事件对象被以实参的形式传递给事件处理函数。

```html
<body>
	<div id="box"></div>
</body>
<script>
	let box = document.querySelector("#box")
    
    //把事件对象被以实参的形式传递给事件处理函数
	box.onclick = function(e){
		console.log(e)
	}
</script>
```

IE8及以前的IE浏览器：需要使用window对象的event属性来获取

```html
<body>
	<div id="box"></div>
</body>
<script>
	let box = document.querySelector("#box") 
	box.onclick = function(){  
        //把事件对象被以实参的形式传递给事件处理函数
		var e = window.event
        console.log(e)
	}
</script>
```

兼容写法

```html
<body>
	<div id="box"></div>
</body>
<script>
	let box = document.querySelector("#box")
	box.onclick = function(e){
		var evt = e || window.event
		console.log(evt)
	}
</script>



<script>
    //优化
	let box = document.querySelector("#box")
	box.onclick = function(e){
		e = e || window.event
		console.log(e)
	}
</script>


```



### 取消默认行为

preventDefault方法

作用：取消页面中某些元素的默认功能，如超链接

格式：e.preventDefault()

注意：IE8及以前的IE浏览器不支持，如果是IE低版本的浏览器，可以使用事件对象.returnValue = false

```html
<body>
    <a href="https://www.baidu.com">跳转到百度</a>
</body>

<script>
	var link = document.querySelector('a')
    link.onclick = function(e){
        e = e || window.event
        e.preventDefault==undefined?(e.returnValue = false):e.preventDefault()
    }
</script>
```

### 鼠标右击事件

```js
<script>
    
    //当在页面上点击鼠标右键时触发
	document.oncontextmenu = function(e){
    	e = e||window.event
    	e.preventDefault==undefined?e.returnValue=false:e.preventDefault()
	}    
</script>
```

### 阻止冒泡事件

谷歌和IE兼容

```js
<script>
	let box = document.querySelector("#box")
	box.onclick = function(e){
		e = e || window.event
		// 兼容写法
		e.stopPropagation == undefined ? e.cancelBubble = true : e.stopPropagation()
	}
</script>
```

### 定时器

window.setInterval() 与 window.clearInterval()

```js
<script>
	(function(){
		console.log("定时器开始...")
		var intervalId = setInterval(function(){
			console.log(111)
		},1000)
		
		var box = document.getElementById("box")
		box.onclick = function(){
			console.log("清除定时器...")
			clearInterval(intervalId)
		}
	})()
</script>
```



